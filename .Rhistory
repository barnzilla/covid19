source("SEIR.n.Age.Classes and friends.R")
# file_name = "BluePrint4 Conceptual model_V4_20200415V2(5agegrp)_SC1.xls"           # File misnamed.  There is only 1 age group in here. Date is prior to April 20.
# file_name = "BluePrint4 Conceptual model_V4_20200415V2(5agegrp)_SC1 - April20.xls" # File misnamed.  There is only 1 age group in here
file_name = "BluePrint4 Conceptual model_V4_20200415V2(1agegrp)_SC1 - April23.xls" # From PHAC"s misnamed "...(1agegrp)_SC1.xls" shared on April 23
if(TRUE)  # random search
{
# NOTE: this is the only place where you name the parameters
# NOTE: use the parameter name as it appears in the relevant Excel spreadsheet
center = c(Cgg=0.25,Cgq=0.0,lambda=-0.75,sigma=-0.75) # Joel solution 5-8 with Cgq set to 0  (exp(Cgq) = 1).
half.range = 0.2 + 0*center
#half.range["beta"] = 0
lower.bound = as.list( center - half.range )
upper.bound = as.list( center + half.range )
n.repeat = 400 # repetitions above and beyond the expansion of upper.bound, lower.bound
racine = 42
use.this.transformation = exp # need to provide a function like exp here
use.this.operation = c("overwrite","add","multiply")[3]
tmin.alter.scope = 40:55
}
# USER HAS NOTHING TO CHANGE BELOW
set.seed(racine)
# Compute all possible candidate by multiplier combinations
#multiplier_combos <- expand.grid(candidates, KEEP.OUT.ATTRS = FALSE)
lower.bound.expanded = expand.grid(lower.bound, KEEP.OUT.ATTRS = FALSE)
upper.bound.expanded = expand.grid(upper.bound, KEEP.OUT.ATTRS = FALSE)
if(any(dim(lower.bound.expanded) != dim(upper.bound.expanded) ))
stop('dimension mismatch')
if(any(colnames(lower.bound.expanded) != colnames(upper.bound.expanded) ))
stop('column name mismatch')
lower.bound.expanded = lower.bound.expanded[rep(seq(nrow(lower.bound.expanded)) , n.repeat ),]
upper.bound.expanded = upper.bound.expanded[rep(seq(nrow(upper.bound.expanded)) , n.repeat ),]
parms.to.try = (upper.bound.expanded - lower.bound.expanded) * runif(prod(dim(upper.bound.expanded)))
parms.to.try = lower.bound.expanded + parms.to.try
parms.to.try = use.this.transformation(parms.to.try)
dim(parms.to.try) # check size of sweep you are about to do  (number of scenarios , number of parameters)
operation_list = list(overwrite = function(current,new)         {0*current+new        } ,
add       = function(current,increment  ) {  current+increment  } ,
multiply  = function(current,mult_factor) {  current*mult_factor} )
operation_func = operation_list[[use.this.operation]]
operation.label = c(overwrite="",add=".add",multiply=".multiplier")[use.this.operation]
# baseline/template
# results.baseline = SEIR.n.Age.Classes(file_name,sheet_names)[c("input.info","input.info.verbatim")] # all you really need
results.baseline = SEIR.n.Age.Classes(file_name,sheet_names)
sheet_names_for_sweep = results.baseline$input.info           # Can use either of those two lines ... in theory (not tested)
sheet_names_for_sweep = results.baseline$input.info.verbatim  # Can use either of those two lines ... in theory (not tested)
baseline.parms.1d = results.baseline$input.info$parms.1d  # data frame of 1d parameters
baseline.parms.2d = results.baseline$input.info$parms.2d  # data frame of 2d parameters
list.sweep = list() #        store results in list  ...
df.sweep = c()      # ... or store results in data.frame
list.sweep.ever.from.inflows = list.sweep.ever.from.outflows = list.sweep
df.sweep.ever.from.inflows =   df.sweep.ever.from.outflows =   df.sweep  # later maybe
outcomes.summary.df = c()
ever.been.here.info= list(ever.been.here.from.inflows="Not done", ever.been.here.from.outflows="Not done")
for(i in 1:nrow(lower.bound.expanded)) {
row <-  parms.to.try[i,]
#this.label <- paste0(names(row),       ".multiplier= ", row, collapse = " , ")
this.label <- paste0(names(row), operation.label, "= ", row, collapse = " , ")
cat("\n Doing",i,"of",nrow(parms.to.try),"simulations :",this.label)
parms.1d = baseline.parms.1d  # data frame of 1d parameters to be altered
parms.2d = baseline.parms.2d  # data frame of 2d parameters to be altered
# Modify the parameter values at the specified tmin.alter.scope
for(parameter in names(row)) {
if(parameter %in% names(parms.1d)) {
parms.1d[parms.1d$tmin %in% tmin.alter.scope, parameter] = operation_func(subset(parms.1d,tmin %in% tmin.alter.scope)[[parameter]] , row[[parameter]] )
} else if(parameter %in% names(parms.2d)) {
parms.2d[parms.2d$tmin %in% tmin.alter.scope, parameter] = operation_func(subset(parms.2d,tmin %in% tmin.alter.scope)[[parameter]] , row[[parameter]] )
} else {
stop(paste(parameter,"was not found in any parameter sheet"))# Parameter was not found in any parameter sheet
}
}
sheet_names_for_sweep$parms.1d = parms.1d # altered data.frame goes in sheet_names_for_sweep
sheet_names_for_sweep$parms.2d = parms.2d # altered data.frame goes in sheet_names_for_sweep
this.result = SEIR.n.Age.Classes(file_name,sheet_names_for_sweep)
# Add on other time series like cumulative incidence
this.result$solution = Add.Other.Outcomes (this.result$solution,parms.1d,"third argument currently inoperant")
# Add on univariate stuff like maxI or maxI.time to outcomes.summary.df
univariate.chunk = Outcomes.Summary(this.result$solution)
univariate.chunk$etiquette = this.label # not sure if this is useful to keep
for(parameter in names(row))
univariate.chunk[[paste0(parameter, operation.label)]] <- row[[parameter]]
outcomes.summary.df = rbind(outcomes.summary.df,univariate.chunk)
# Get ever.been.here info
# ever.been.here.info = ever.been.here(this.result) # this.result has been altered above but should not cause harm
#Update list.sweep and df.sweep
list.sweep[[this.label]] = this.result$solution
list.sweep.ever.from.inflows [[this.label]] = ever.been.here.info$ever.been.here.from.inflows
list.sweep.ever.from.outflows[[this.label]] = ever.been.here.info$ever.been.here.from.outflows
# Add this.label and the parameter multpliers to the this.result$solution data frame
this.result$solution$etiquette <- this.label
for(parameter in names(row)) {
this.result$solution[[paste0(parameter, operation.label)]] <- row[[parameter]]
}
df.sweep = rbind(df.sweep,this.result$solution)
}
names(list.sweep)[1:2]
names(df.sweep)
table(df.sweep$etiquette)[1:2]
names(outcomes.summary.df)
# USER HAS NOTHING TO CHANGE BELOW
set.seed(racine)
# Compute all possible candidate by multiplier combinations
#multiplier_combos <- expand.grid(candidates, KEEP.OUT.ATTRS = FALSE)
lower.bound.expanded = expand.grid(lower.bound, KEEP.OUT.ATTRS = FALSE)
upper.bound.expanded = expand.grid(upper.bound, KEEP.OUT.ATTRS = FALSE)
if(any(dim(lower.bound.expanded) != dim(upper.bound.expanded) ))
stop('dimension mismatch')
if(any(colnames(lower.bound.expanded) != colnames(upper.bound.expanded) ))
stop('column name mismatch')
lower.bound.expanded = lower.bound.expanded[rep(seq(nrow(lower.bound.expanded)) , n.repeat ),]
upper.bound.expanded = upper.bound.expanded[rep(seq(nrow(upper.bound.expanded)) , n.repeat ),]
parms.to.try = (upper.bound.expanded - lower.bound.expanded) * runif(prod(dim(upper.bound.expanded)))
parms.to.try = lower.bound.expanded + parms.to.try
parms.to.try = use.this.transformation(parms.to.try)
dim(parms.to.try) # check size of sweep you are about to do  (number of scenarios , number of parameters)
operation_list = list(overwrite = function(current,new)         {0*current+new        } ,
add       = function(current,increment  ) {  current+increment  } ,
multiply  = function(current,mult_factor) {  current*mult_factor} )
operation_func = operation_list[[use.this.operation]]
operation.label = c(overwrite="",add=".add",multiply=".multiplier")[use.this.operation]
# baseline/template
# results.baseline = SEIR.n.Age.Classes(file_name,sheet_names)[c("input.info","input.info.verbatim")] # all you really need
results.baseline = SEIR.n.Age.Classes(file_name,sheet_names)
sheet_names_for_sweep = results.baseline$input.info           # Can use either of those two lines ... in theory (not tested)
sheet_names_for_sweep = results.baseline$input.info.verbatim  # Can use either of those two lines ... in theory (not tested)
baseline.parms.1d = results.baseline$input.info$parms.1d  # data frame of 1d parameters
baseline.parms.2d = results.baseline$input.info$parms.2d  # data frame of 2d parameters
list.sweep = list() #        store results in list  ...
df.sweep = c()      # ... or store results in data.frame
list.sweep.ever.from.inflows = list.sweep.ever.from.outflows = list.sweep
df.sweep.ever.from.inflows =   df.sweep.ever.from.outflows =   df.sweep  # later maybe
outcomes.summary.df = c()
ever.been.here.info= list(ever.been.here.from.inflows="Not done", ever.been.here.from.outflows="Not done")
for(i in 1:nrow(lower.bound.expanded)) {
row <-  parms.to.try[i,]
#this.label <- paste0(names(row),       ".multiplier= ", row, collapse = " , ")
this.label <- paste0(names(row), operation.label, "= ", row, collapse = " , ")
cat("\n Doing",i,"of",nrow(parms.to.try),"simulations :",this.label)
parms.1d = baseline.parms.1d  # data frame of 1d parameters to be altered
parms.2d = baseline.parms.2d  # data frame of 2d parameters to be altered
# Modify the parameter values at the specified tmin.alter.scope
for(parameter in names(row)) {
if(parameter %in% names(parms.1d)) {
parms.1d[parms.1d$tmin %in% tmin.alter.scope, parameter] = operation_func(subset(parms.1d,tmin %in% tmin.alter.scope)[[parameter]] , row[[parameter]] )
} else if(parameter %in% names(parms.2d)) {
parms.2d[parms.2d$tmin %in% tmin.alter.scope, parameter] = operation_func(subset(parms.2d,tmin %in% tmin.alter.scope)[[parameter]] , row[[parameter]] )
} else {
stop(paste(parameter,"was not found in any parameter sheet"))# Parameter was not found in any parameter sheet
}
}
sheet_names_for_sweep$parms.1d = parms.1d # altered data.frame goes in sheet_names_for_sweep
sheet_names_for_sweep$parms.2d = parms.2d # altered data.frame goes in sheet_names_for_sweep
this.result = SEIR.n.Age.Classes(file_name,sheet_names_for_sweep)
# Add on other time series like cumulative incidence
this.result$solution = Add.Other.Outcomes (this.result$solution,parms.1d,"third argument currently inoperant")
# Add on univariate stuff like maxI or maxI.time to outcomes.summary.df
univariate.chunk = Outcomes.Summary(this.result$solution)
univariate.chunk$etiquette = this.label # not sure if this is useful to keep
for(parameter in names(row))
univariate.chunk[[paste0(parameter, operation.label)]] <- row[[parameter]]
outcomes.summary.df = rbind(outcomes.summary.df,univariate.chunk)
# Get ever.been.here info
# ever.been.here.info = ever.been.here(this.result) # this.result has been altered above but should not cause harm
#Update list.sweep and df.sweep
list.sweep[[this.label]] = this.result$solution
list.sweep.ever.from.inflows [[this.label]] = ever.been.here.info$ever.been.here.from.inflows
list.sweep.ever.from.outflows[[this.label]] = ever.been.here.info$ever.been.here.from.outflows
# Add this.label and the parameter multpliers to the this.result$solution data frame
this.result$solution$etiquette <- this.label
for(parameter in names(row)) {
this.result$solution[[paste0(parameter, operation.label)]] <- row[[parameter]]
}
df.sweep = rbind(df.sweep,this.result$solution)
}
# USER HAS NOTHING TO CHANGE BELOW
set.seed(racine)
# Compute all possible candidate by multiplier combinations
#multiplier_combos <- expand.grid(candidates, KEEP.OUT.ATTRS = FALSE)
lower.bound.expanded = expand.grid(lower.bound, KEEP.OUT.ATTRS = FALSE)
upper.bound.expanded = expand.grid(upper.bound, KEEP.OUT.ATTRS = FALSE)
if(any(dim(lower.bound.expanded) != dim(upper.bound.expanded) ))
stop('dimension mismatch')
if(any(colnames(lower.bound.expanded) != colnames(upper.bound.expanded) ))
stop('column name mismatch')
lower.bound.expanded = lower.bound.expanded[rep(seq(nrow(lower.bound.expanded)) , n.repeat ),]
upper.bound.expanded = upper.bound.expanded[rep(seq(nrow(upper.bound.expanded)) , n.repeat ),]
parms.to.try = (upper.bound.expanded - lower.bound.expanded) * runif(prod(dim(upper.bound.expanded)))
parms.to.try = lower.bound.expanded + parms.to.try
parms.to.try = use.this.transformation(parms.to.try)
dim(parms.to.try) # check size of sweep you are about to do  (number of scenarios , number of parameters)
operation_list = list(overwrite = function(current,new)         {0*current+new        } ,
add       = function(current,increment  ) {  current+increment  } ,
multiply  = function(current,mult_factor) {  current*mult_factor} )
operation_func = operation_list[[use.this.operation]]
operation.label = c(overwrite="",add=".add",multiply=".multiplier")[use.this.operation]
# baseline/template
# results.baseline = SEIR.n.Age.Classes(file_name,sheet_names)[c("input.info","input.info.verbatim")] # all you really need
results.baseline = SEIR.n.Age.Classes(file_name,sheet_names)
sheet_names = list(initial.conditions="Initial conditions",parms.1d="Parameters by Age",parms.2d="Parameters by Age x Age",model.flow="Model Specs (not lazy)",auxiliary.vars="Intermediate calculations")
# USER HAS NOTHING TO CHANGE BELOW
set.seed(racine)
# Compute all possible candidate by multiplier combinations
#multiplier_combos <- expand.grid(candidates, KEEP.OUT.ATTRS = FALSE)
lower.bound.expanded = expand.grid(lower.bound, KEEP.OUT.ATTRS = FALSE)
upper.bound.expanded = expand.grid(upper.bound, KEEP.OUT.ATTRS = FALSE)
if(any(dim(lower.bound.expanded) != dim(upper.bound.expanded) ))
stop('dimension mismatch')
if(any(colnames(lower.bound.expanded) != colnames(upper.bound.expanded) ))
stop('column name mismatch')
lower.bound.expanded = lower.bound.expanded[rep(seq(nrow(lower.bound.expanded)) , n.repeat ),]
upper.bound.expanded = upper.bound.expanded[rep(seq(nrow(upper.bound.expanded)) , n.repeat ),]
parms.to.try = (upper.bound.expanded - lower.bound.expanded) * runif(prod(dim(upper.bound.expanded)))
parms.to.try = lower.bound.expanded + parms.to.try
parms.to.try = use.this.transformation(parms.to.try)
dim(parms.to.try) # check size of sweep you are about to do  (number of scenarios , number of parameters)
operation_list = list(overwrite = function(current,new)         {0*current+new        } ,
add       = function(current,increment  ) {  current+increment  } ,
multiply  = function(current,mult_factor) {  current*mult_factor} )
operation_func = operation_list[[use.this.operation]]
operation.label = c(overwrite="",add=".add",multiply=".multiplier")[use.this.operation]
# baseline/template
# results.baseline = SEIR.n.Age.Classes(file_name,sheet_names)[c("input.info","input.info.verbatim")] # all you really need
results.baseline = SEIR.n.Age.Classes(file_name,sheet_names)
sheet_names_for_sweep = results.baseline$input.info           # Can use either of those two lines ... in theory (not tested)
sheet_names_for_sweep = results.baseline$input.info.verbatim  # Can use either of those two lines ... in theory (not tested)
baseline.parms.1d = results.baseline$input.info$parms.1d  # data frame of 1d parameters
baseline.parms.2d = results.baseline$input.info$parms.2d  # data frame of 2d parameters
list.sweep = list() #        store results in list  ...
df.sweep = c()      # ... or store results in data.frame
list.sweep.ever.from.inflows = list.sweep.ever.from.outflows = list.sweep
df.sweep.ever.from.inflows =   df.sweep.ever.from.outflows =   df.sweep  # later maybe
outcomes.summary.df = c()
ever.been.here.info= list(ever.been.here.from.inflows="Not done", ever.been.here.from.outflows="Not done")
for(i in 1:nrow(lower.bound.expanded)) {
row <-  parms.to.try[i,]
#this.label <- paste0(names(row),       ".multiplier= ", row, collapse = " , ")
this.label <- paste0(names(row), operation.label, "= ", row, collapse = " , ")
cat("\n Doing",i,"of",nrow(parms.to.try),"simulations :",this.label)
parms.1d = baseline.parms.1d  # data frame of 1d parameters to be altered
parms.2d = baseline.parms.2d  # data frame of 2d parameters to be altered
# Modify the parameter values at the specified tmin.alter.scope
for(parameter in names(row)) {
if(parameter %in% names(parms.1d)) {
parms.1d[parms.1d$tmin %in% tmin.alter.scope, parameter] = operation_func(subset(parms.1d,tmin %in% tmin.alter.scope)[[parameter]] , row[[parameter]] )
} else if(parameter %in% names(parms.2d)) {
parms.2d[parms.2d$tmin %in% tmin.alter.scope, parameter] = operation_func(subset(parms.2d,tmin %in% tmin.alter.scope)[[parameter]] , row[[parameter]] )
} else {
stop(paste(parameter,"was not found in any parameter sheet"))# Parameter was not found in any parameter sheet
}
}
sheet_names_for_sweep$parms.1d = parms.1d # altered data.frame goes in sheet_names_for_sweep
sheet_names_for_sweep$parms.2d = parms.2d # altered data.frame goes in sheet_names_for_sweep
this.result = SEIR.n.Age.Classes(file_name,sheet_names_for_sweep)
# Add on other time series like cumulative incidence
this.result$solution = Add.Other.Outcomes (this.result$solution,parms.1d,"third argument currently inoperant")
# Add on univariate stuff like maxI or maxI.time to outcomes.summary.df
univariate.chunk = Outcomes.Summary(this.result$solution)
univariate.chunk$etiquette = this.label # not sure if this is useful to keep
for(parameter in names(row))
univariate.chunk[[paste0(parameter, operation.label)]] <- row[[parameter]]
outcomes.summary.df = rbind(outcomes.summary.df,univariate.chunk)
# Get ever.been.here info
# ever.been.here.info = ever.been.here(this.result) # this.result has been altered above but should not cause harm
#Update list.sweep and df.sweep
list.sweep[[this.label]] = this.result$solution
list.sweep.ever.from.inflows [[this.label]] = ever.been.here.info$ever.been.here.from.inflows
list.sweep.ever.from.outflows[[this.label]] = ever.been.here.info$ever.been.here.from.outflows
# Add this.label and the parameter multpliers to the this.result$solution data frame
this.result$solution$etiquette <- this.label
for(parameter in names(row)) {
this.result$solution[[paste0(parameter, operation.label)]] <- row[[parameter]]
}
df.sweep = rbind(df.sweep,this.result$solution)
}
plot(outcomes.summary.df$maxI.time, outcomes.summary.df$maxI)
plot(outcomes.summary.df$maxI.time, outcomes.summary.df$cumI.75days)
min(outcomes.summary.df$maxI.time)
max(outcomes.summary.df$maxI.time)
max(outcomes.summary.df$maxI)
max(outcomes.summary.df$cumI.75days)
shiny::runApp('C:/Users/Joel/Desktop/Test')
install.packages('rsconnect')
rsconnect::setAccountInfo(name='microsim',
token='D16FD2CD0AEC0310F90F2870D433654C',
secret='Fag3t0zyOZI59TOmTXK7ZkeMyHM7Zis9CT8fklOJ')
library(rsconnect)
rsconnect::deployApp('c:/users/joel/desktop/test/app.r')
rsconnect::deployApp('c:/users/joel/desktop/test')
shiny::runApp('C:/Users/Joel/Desktop/Test')
files <- list.files(path = "c:/users/joel/google drive/github/covid19", pattern = "*.xlsx", full.names = T)
files
strsplit(files, "updated ")
strsplit(files, "updated ")[[2]]
files
shiny::runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
# Wrangle the raw data
wrangle_data <- function(d) {
# Reshape data from long to wide format
d_wide <- spread(d %>% select("Case identifier number", "Case information", VALUE, REF_DATE), "Case information", VALUE)
# Add leading zeros to case identifier number
d_wide$`Case identifier number` <- str_pad(d_wide$`Case identifier number`, width = nchar(max(as.numeric(d$`Case identifier number`))), pad = "0")
# Identify select vectors
vectors_to_factor <- c("Age group", "Gender", "Transmission", "Hospitalization", "Intensive care unit", "Death")
# Restructure as factors
d_wide[vectors_to_factor] <- lapply(d_wide[vectors_to_factor], factor)
# Add semantic labels
d_wide$`Age group` <- revalue(d_wide$`Age group`, c("1" = "0-19", "2" = "20-29", "3" = "30-39", "4" = "40-49", "5" = "50-59", "6" = "60-69", "7" = "70-79", "8" = "80+", "99" = "Not stated"))
d_wide$Gender <- revalue(d_wide$Gender, c("1" = "Male", "2" = "Female", "7" = "Non-binary", "9" = "Not stated"))
d_wide$Transmission <- revalue(d_wide$Transmission, c("1" = "Travel exposure", "2" = "Community exposure", "3" = "Pending"))
d_wide$Hospitalization <- revalue(d_wide$Hospitalization, c("1" = "Yes", "2" = "No", "9" = "Not stated"))
d_wide$`Intensive care unit` <- revalue(d_wide$`Intensive care unit`, c("1" = "Yes", "2" = "No", "9" = "Not stated"))
d_wide$Death <- revalue(d_wide$Death, c("1" = "Yes", "2" = "No", "9" = "Not stated"))
# Add day, month and reference year vectors together and structure as a date object
d_wide$`Episode date` <- as.Date(paste0(d_wide$REF_DATE, "-", str_pad(d_wide$`Episode date - month`, 2, pad = "0"), "-", str_pad(d_wide$`Episode date - day`, 2, pad = "0")), format = "%Y-%m-%d")
# Change format to %d-%b-%y
d_wide$`Episode date` <- format(d_wide$`Episode date`, format = "%d-%b-%y")
# Remove unwanted vectors from data
d_wide <- d_wide %>% select("Case identifier number", "Episode date", Gender, "Age group", Transmission, Hospitalization, "Intensive care unit", Death)
# Rename vectors
names(d_wide) <- c("CaseID", "Episode Date", "Gender", "Age Group", "Exposure Setting", "Hospitalized", "Intensive Care Unit", "Death")
# Order data by case ids in ascending order
d_wide <- d_wide %>% arrange(CaseID)
# Export data to Excel
write.xlsx2(as.data.frame(d_wide), paste0("Table 13-10-0766-01 - updated ", format(Sys.time(), "%Y-%m-%d"), ".xlsx"), row.names = FALSE, showNA = FALSE)
return(d_wide)
}
library("cansim")
library("tidyverse")
d <- get_cansim("13-10-0766-01", refresh = TRUE)
View(d)
d <- wrangle_data(d)
getwd()
setwd("c:/users/joel/google drive/github/covid19")
getwd()
write.xlsx2(as.data.frame(d_wide), paste0("Table 13-10-0766-01 - updated ", format(Sys.time(), "%Y-%m-%d"), ".xlsx"), row.names = FALSE, showNA = FALSE)
write.xlsx2(d, paste0("Table 13-10-0766-01 - updated ", format(Sys.time(), "%Y-%m-%d"), ".xlsx"), row.names = FALSE, showNA = FALSE)
write.csv(d, paste0("Table 13-10-0766-01 - updated ", format(Sys.time(), "%Y-%m-%d"), ".csv"), row.names = FALSE, na="")
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
list.files()
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
list.files()
list.files()
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
list.files()
list.files(patter = "*.xlsx")
! list.files(patter = "*.xlsx") %in% "~"
a = list.files(patter = "*.xlsx")
grep("~", a)
a = sort(a, decreasing = TRUE)
a
grep("~", a)
a
grep("~", a)[-grep("~", a)]
a[-grep("~", a)]
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
list.files()
list.files(pattern = "*.xlsx")
list.files(pattern = "^[^~]*.xlsx")
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
d <- get_cansim("13-10-0766-01", refresh = TRUE)
d_wide <- spread(d %>% select("Case identifier number", "Case information", VALUE, REF_DATE), "Case information", VALUE)
nrow(d)
View(d)
d_wide <- spread(d %>% select("Case identifier number", "Case information", VALUE, REF_DATE), "Case information", VALUE)
nrow(d_wide)
d <- get_cansim("13-10-0766-01", refresh = TRUE)
d_wide <- spread(d %>% select("Case identifier number", "Case information", VALUE, REF_DATE), "Case information", VALUE)
nrow(d_wide)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, dpi = 300)
# Chunk 2
# Define packages that will be used to extend base R
package_names <- c("cansim", "DT", "ggplot2", "plyr", "plotly", "scales", "tidyverse", "xlsx")
# Install any packages that do not exist
install_packages <- lapply(package_names, FUN = function(x) if(! require(x, character.only = TRUE)) install.packages(x))
# Load the packages
load_packages <- lapply(package_names, require, character.only = TRUE)
# Chunk 3
d <- get_cansim("13-10-0766-01", refresh = TRUE)
# Chunk 4
d_wide <- spread(d %>% select("Case identifier number", "Case information", VALUE, REF_DATE), "Case information", VALUE)
# Chunk 5
d_wide$`Case identifier number` <- str_pad(d_wide$`Case identifier number`, width = nchar(max(as.numeric(d$`Case identifier number`))), pad = "0")
# Chunk 6
# Identify vectors
vectors_to_factor <- c("Age group", "Gender", "Transmission", "Hospitalization", "Intensive care unit", "Death")
# Restructure as factors
d_wide[vectors_to_factor] <- lapply(d_wide[vectors_to_factor], factor)
# Add semantic labels
d_wide$`Age group` <- revalue(d_wide$`Age group`, c("1" = "0-19", "2" = "20-29", "3" = "30-39", "4" = "40-49", "5" = "50-59", "6" = "60-69", "7" = "70-79", "8" = "80+", "99" = "Not stated"))
d_wide$Gender <- revalue(d_wide$Gender, c("1" = "Male", "2" = "Female", "7" = "Non-binary", "9" = "Not stated"))
d_wide$Transmission <- revalue(d_wide$Transmission, c("1" = "Travel exposure", "2" = "Community exposure", "3" = "Pending"))
d_wide$Hospitalization <- revalue(d_wide$Hospitalization, c("1" = "Yes", "2" = "No", "9" = "Not stated"))
d_wide$`Intensive care unit` <- revalue(d_wide$`Intensive care unit`, c("1" = "Yes", "2" = "No", "9" = "Not stated"))
d_wide$Death <- revalue(d_wide$Death, c("1" = "Yes", "2" = "No", "9" = "Not stated"))
# Chunk 7
# Add day, month and reference year vectors together and structure as a date object
d_wide$`Episode date` <- as.Date(paste0(d_wide$REF_DATE, "-", str_pad(d_wide$`Episode date - month`, 2, pad = "0"), "-", str_pad(d_wide$`Episode date - day`, 2, pad = "0")), format = "%Y-%m-%d")
# Change format to %d-%b-%y
d_wide$`Episode date` <- format(d_wide$`Episode date`, format = "%d-%b-%y")
# Chunk 8
d_wide <- d_wide %>% select("Case identifier number", "Episode date", Gender, "Age group", Transmission, Hospitalization, "Intensive care unit", Death)
# Chunk 9
names(d_wide) <- c("CaseID", "Episode Date", "Gender", "Age Group", "Exposure Setting", "Hospitalized", "Intensive Care Unit", "Death")
# Chunk 10
d_wide <- d_wide %>% arrange(CaseID)
write.xlsx2(as.data.frame(d_wide), paste0("c:/users/joel/google drive/github/covid19/Table 13-10-0766-01 - updated ", format(Sys.time(), "%Y-%m-%d"), ".xlsx"), row.names = FALSE, showNA = FALSE)
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
a <- read_xlsx("Table 13-10-0766-01 - updated 2020-04-28.xlsx")
min(a$`Episode Date`)
min(as.Date(a$`Episode Date`))
min(as.Date(a$`Episode Date`, format = "%d-%b-%y"))
b = as.Date(a$`Episode Date`, format = "%d-%b-%y")
b
str(b)
min(b)
str(b)
sort(b)
min(b)
sort(a$`Episode Date`)[1]
sort(as.Date(a$`Episode Date`, format = "%d-%b-%y"))[1]
str(sort(as.Date(a$`Episode Date`, format = "%d-%b-%y"))[1])
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
d <- get_cansim("13-10-0766-01", refresh = TRUE)
d_wide <- spread(d %>% select("Case identifier number", "Case information", VALUE, REF_DATE), "Case information", VALUE)
nrow(d_wide)
Sys.time()
?Sys.time
as.POSIXct(Sys.time(), tz="Europe/London")
as.POSIXct(Sys.time(), tz="UTC")
as.POSIXct(Sys.time(tz = "UTC"))
current_time <- as.POSIXct(Sys.time())
current_time
as.POSIXct(current_time, tz = "UTC")
as.POSIXct(current_time, tz = "Europe/London")
library("lubridate")
now()
?now
now(tzone = "UTC")
now(tzone = "UTC") + 6
now(tzone = "UTC") + hours(6)
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
is.equal(a,b)
all.equal(a, b)
a <- tibble(a = 1:10)
b <- tibble (a = 1:10)
all.equal(a, b)
b <- tibble (a = 1:11)
all.equal(a, b)
isTRUE(all.equal(a, b))
now()
now(tzone = "UTC")
?now
now
a <- now(tzone = "UTC")
a
str(a)
?now
as_date(a)
now
a <- now(tzone = UTC) - hours(4)
a <- now(tzone = "UTC") - hours(4)
a
format(now(), "%Y-%m-%d")
now(tzone = "UTC")
hnow(tzone = "UTC") - hours(4)
now(tzone = "UTC") - hours(4)
a = now(tzone = "UTC") - hours(4)
as_date(a)
now <- now(tzone = "UTC")
now
now - hours(12)
now - hours(18)
now - hours(26)
now
format(now, "%h")
format(now, "%H")
as.integer(format(now, "%H"))
now
a <- 1:10
all.equal(a, a)
b = all.equal(a, a)
isTRUE(b)
! isTRUE(b)
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
runApp('C:/Users/Joel/Google Drive/GitHub/covid19')
